# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FTWDialog
                                 A QGIS plugin
 A plugin to use FTW models to generate field boundaries
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-20
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Fields of The World Team
        email                : gedeonmuhawenayo@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import uuid
import urllib.request
from pathlib import Path

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsProject, QgsRasterLayer, QgsApplication
from qgis.utils import iface

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ftw_plugin_dialog_base.ui'))

# Model configurations
MODEL_CONFIGS = {
    "FTW 3 Classes": {
        "url": "https://github.com/fieldsoftheworld/ftw-baselines/releases/download/v1/3_Class_FULL_FTW_Pretrained.ckpt",
        "filename": "3_Class_FULL_FTW_Pretrained.ckpt"
    },
    "FTW 2 Classes": {
        "url": "https://github.com/fieldsoftheworld/ftw-baselines/releases/download/v1/2_Class_FULL_FTW_Pretrained.ckpt",
        "filename": "2_Class_FULL_FTW_Pretrained.ckpt"
    }
}

valid_filenames = ", ".join(config["filename"] for config in MODEL_CONFIGS.values())


class FTWDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(FTWDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        
        # Connect the quit button to close the dialog
        self.quit_button.clicked.connect(self.close)
        
        # Connect the raster path button to file dialog
        self.raster_path.clicked.connect(self.browse_raster)
        
        # Connect the model path button to file dialog
        self.model_path.clicked.connect(self.browse_model)
        
        # Connect run button
        self.run_button.clicked.connect(self.run_process)
        
        # Connect add_map button
        self.add_map.clicked.connect(self.add_visualizations_to_map)
        
        # Connect checkboxes for enabling/disabling the add_map button
        self.win_a.stateChanged.connect(self.update_add_map_button_state)
        self.win_b.stateChanged.connect(self.update_add_map_button_state)
        self.nir.stateChanged.connect(self.update_add_map_button_state)
        
        # Setup model combo box
        self.setup_model_combo()
        
        # Populate the raster combo box with available layers
        self.populate_raster_combo()
    
    def setup_model_combo(self):
        """Setup the model selection combo box."""
        self.model_name.clear()
        for model_name in MODEL_CONFIGS.keys():
            self.model_name.addItem(model_name)
    
    def get_models_dir(self):
        """Get the directory where models should be stored."""
        # Use QGIS user profile directory to store models
        profile_dir = QgsApplication.qgisSettingsDirPath()
        models_dir = os.path.join(profile_dir, 'ftw_models')
        os.makedirs(models_dir, exist_ok=True)
        return models_dir
    
    def ensure_model_downloaded(self, model_name):
        """Ensure the selected model is downloaded and return its path."""
        if model_name not in MODEL_CONFIGS:
            return None
            
        config = MODEL_CONFIGS[model_name]
        models_dir = self.get_models_dir()
        model_path = os.path.join(models_dir, config['filename'])
        
        # Check if model exists
        if not os.path.exists(model_path):
            try:
                # Show progress dialog
                progress = QtWidgets.QProgressDialog(
                    f"Downloading {model_name}...",
                    "Cancel",
                    0,
                    100,
                    self
                )
                progress.setWindowModality(Qt.WindowModal)
                progress.setAutoClose(True)
                progress.show()
                
                def update_progress(block_num, block_size, total_size):
                    downloaded = block_num * block_size
                    if total_size > 0:
                        percent = min(100, int(downloaded * 100 / total_size))
                        progress.setValue(percent)
                        QtWidgets.QApplication.processEvents()
                
                # Download the model
                urllib.request.urlretrieve(
                    config['url'],
                    model_path,
                    reporthook=update_progress
                )
                
                progress.close()
                return model_path
                
            except Exception as e:
                QtWidgets.QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to download model: {str(e)}"
                )
                if os.path.exists(model_path):
                    os.remove(model_path)
                return None
        
        return model_path

    def populate_raster_combo(self):
        """Populate the raster combo box with available raster layers from QGIS."""
        # Clear existing items
        self.raster_name.clear()
        
        # Get all layers from the project
        layers = QgsProject.instance().mapLayers().values()
        
        # Filter and add only raster layers to the combo box
        for layer in layers:
            if isinstance(layer, QgsRasterLayer):
                self.raster_name.addItem(layer.name(), layer.id())

    def browse_raster(self):
        """Open file dialog to select a raster file and add it to QGIS."""
        # Open file dialog
        file_dialog = QtWidgets.QFileDialog()
        raster_path, _ = file_dialog.getOpenFileName(
            self,
            "Select Raster Layer",
            "",
            "Raster Files (*.tif *.tiff *.img *.jp2 *.asc);;All Files (*.*)"
        )
        
        if raster_path:
            # Get the filename without extension as the layer name
            layer_name = os.path.splitext(os.path.basename(raster_path))[0]
            
            # Create and add the raster layer to QGIS
            raster_layer = QgsRasterLayer(raster_path, layer_name)
            if raster_layer.isValid():
                QgsProject.instance().addMapLayer(raster_layer)
                
                # Update the combo box and select the new layer
                self.populate_raster_combo()
                index = self.raster_name.findData(raster_layer.id())
                if index >= 0:
                    self.raster_name.setCurrentIndex(index)
            else:
                # Show error message if layer is invalid
                QtWidgets.QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to load raster layer: {raster_path}"
                )

    def browse_model(self):
        """Open file dialog to select a model checkpoint file."""
        # Open file dialog
        file_dialog = QtWidgets.QFileDialog()
        model_path, _ = file_dialog.getOpenFileName(
            self,
            "Select Model Checkpoint",
            "",
            "Checkpoint Files (*.ckpt);;All Files (*.*)"
        )
        
        if model_path:
            # Get the filename without extension
            model_name = os.path.splitext(os.path.basename(model_path))[0]
            
            # Check if this is a known model type
            known_model = False
            for config_name, config in MODEL_CONFIGS.items():
                if config['filename'] == os.path.basename(model_path):
                    # Select the corresponding model type in combo box
                    index = self.model_name.findText(config_name)
                    if index >= 0:
                        self.model_name.setCurrentIndex(index)
                    known_model = True
                    break
            
            if not known_model:
                # Warn user if this is not a known model type
                QtWidgets.QMessageBox.warning(
                    self,
                    "Warning",
                    f"This is not a standard FTW model checkpoint.\n\n"
                    f"Please ensure the model filename is one of:\n{valid_filenames}"
                )
            
            # Copy the model to the models directory for future use
            try:
                models_dir = self.get_models_dir()
                target_path = os.path.join(models_dir, os.path.basename(model_path))
                
                # Only copy if it's not already in the models directory
                if model_path != target_path:
                    import shutil
                    shutil.copy2(model_path, target_path)
                
            except Exception as e:
                QtWidgets.QMessageBox.warning(
                    self,
                    "Warning",
                    f"Failed to copy model to plugin directory: {str(e)}"
                )

    def update_add_map_button_state(self):
        """Enable or disable the add_map button based on checkbox states."""
        # Enable the button if any visualization option is checked
        self.add_map.setEnabled(
            self.win_a.isChecked() or self.win_b.isChecked() or self.nir.isChecked()
        )
    
    def add_visualizations_to_map(self):
        """Add selected visualizations to the map."""
        # Get the selected raster layer
        selected_layer_id = self.raster_name.currentData()
        if not selected_layer_id:
            QtWidgets.QMessageBox.warning(
                self,
                "Warning",
                "Please select a raster layer first."
            )
            return
            
        selected_layer = QgsProject.instance().mapLayer(selected_layer_id)
        if not selected_layer or not selected_layer.isValid():
            QtWidgets.QMessageBox.warning(
                self,
                "Warning",
                "Selected layer is not valid."
            )
            return
            
        # Create visualizations based on checkbox states
        self.visualize_bands(selected_layer)
        
    def visualize_bands(self, source_layer):
        """Create band visualizations based on checkbox states."""
        if not (self.win_a.isChecked() or self.win_b.isChecked() or self.nir.isChecked()):
            return
            
        source_path = source_layer.source()
        
        # Handle Window A visualization (Bands 1,2,3)
        if self.win_a.isChecked():
            layer_name = f"{source_layer.name()}_win_A_{str(uuid.uuid4())[:8]}"
            win_a_layer = QgsRasterLayer(source_path, layer_name)
            if win_a_layer.isValid():
                # Set band rendering for R,G,B as 1,2,3
                win_a_layer.renderer().setRedBand(1)
                win_a_layer.renderer().setGreenBand(2)
                win_a_layer.renderer().setBlueBand(3)
                QgsProject.instance().addMapLayer(win_a_layer)
            else:
                QtWidgets.QMessageBox.warning(
                    self,
                    "Warning",
                    f"Failed to create Window A visualization for {source_layer.name()}"
                )
        
        # Handle Window B visualization (Bands 5,6,7)
        if self.win_b.isChecked():
            layer_name = f"{source_layer.name()}_win_B_{str(uuid.uuid4())[:8]}"
            win_b_layer = QgsRasterLayer(source_path, layer_name)
            if win_b_layer.isValid():
                # Set band rendering for R,G,B as 5,6,7
                win_b_layer.renderer().setRedBand(5)
                win_b_layer.renderer().setGreenBand(6)
                win_b_layer.renderer().setBlueBand(7)
                QgsProject.instance().addMapLayer(win_b_layer)
            else:
                QtWidgets.QMessageBox.warning(
                    self,
                    "Warning",
                    f"Failed to create Window B visualization for {source_layer.name()}"
                )
        
        # Handle NIR false color visualizations
        if self.nir.isChecked():
            # NIR false color for Window A (Bands 4,1,2 for NIR,R,G)
            layer_name = f"{source_layer.name()}_NIR_A_{str(uuid.uuid4())[:8]}"
            nir_a_layer = QgsRasterLayer(source_path, layer_name)
            if nir_a_layer.isValid():
                # Set band rendering for R,G,B as 4,1,2 (NIR, Red, Green)
                nir_a_layer.renderer().setRedBand(4)
                nir_a_layer.renderer().setGreenBand(1)
                nir_a_layer.renderer().setBlueBand(2)
                QgsProject.instance().addMapLayer(nir_a_layer)
            else:
                QtWidgets.QMessageBox.warning(
                    self,
                    "Warning",
                    f"Failed to create NIR Window A visualization for {source_layer.name()}"
                )
                
            # NIR false color for Window B (Bands 8,5,6 for NIR,R,G)
            layer_name = f"{source_layer.name()}_NIR_B_{str(uuid.uuid4())[:8]}"
            nir_b_layer = QgsRasterLayer(source_path, layer_name)
            if nir_b_layer.isValid():
                # Set band rendering for R,G,B as 8,5,6 (NIR, Red, Green)
                nir_b_layer.renderer().setRedBand(8)
                nir_b_layer.renderer().setGreenBand(5)
                nir_b_layer.renderer().setBlueBand(6)
                QgsProject.instance().addMapLayer(nir_b_layer)
            else:
                QtWidgets.QMessageBox.warning(
                    self,
                    "Warning",
                    f"Failed to create NIR Window B visualization for {source_layer.name()}"
                )
        
        # Refresh the map canvas
        iface.mapCanvas().refresh()
        
    def run_process(self):
        """Handle the run button click event."""
        # Get the selected raster layer
        selected_layer_id = self.raster_name.currentData()
        if not selected_layer_id:
            QtWidgets.QMessageBox.warning(
                self,
                "Warning",
                "Please select a raster layer first."
            )
            return
            
        selected_layer = QgsProject.instance().mapLayer(selected_layer_id)
        if not selected_layer or not selected_layer.isValid():
            QtWidgets.QMessageBox.warning(
                self,
                "Warning",
                "Selected layer is not valid."
            )
            return
        
        # Handle model download if needed
        selected_model = self.model_name.currentText()
        model_path = self.ensure_model_downloaded(selected_model)
        if not model_path:
            QtWidgets.QMessageBox.warning(
                self,
                "Warning",
                "Failed to get model checkpoint."
            )
            return
        
        # Removed visualization step - only done by add_map button now
        
        # TODO: Add other processing steps here
